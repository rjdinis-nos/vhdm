// Example: internal/wsl/client.go
// WSL operations client

package wsl

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"os"
	"os/exec"
	"regexp"
	"strings"
	"time"

	"github.com/user/vhdm/internal/logging"
	"github.com/user/vhdm/internal/types"
)

// Client handles WSL operations
type Client struct {
	logger           *logging.Logger
	sleepAfterAttach time.Duration
	detachTimeout    time.Duration
}

// NewClient creates a new WSL client
func NewClient(logger *logging.Logger) *Client {
	return &Client{
		logger:           logger,
		sleepAfterAttach: 2 * time.Second,
		detachTimeout:    30 * time.Second,
	}
}

// ConvertPath converts Windows path to WSL path
func (c *Client) ConvertPath(winPath string) string {
	// C:/path/to/file -> /mnt/c/path/to/file
	if len(winPath) < 2 {
		return winPath
	}
	
	// Replace backslashes with forward slashes
	path := strings.ReplaceAll(winPath, "\\", "/")
	
	// Convert drive letter
	if path[1] == ':' {
		drive := strings.ToLower(string(path[0]))
		return "/mnt/" + drive + path[2:]
	}
	
	return path
}

// FileExists checks if a file exists
func (c *Client) FileExists(path string) bool {
	_, err := os.Stat(path)
	return err == nil
}

// EnsureInterop ensures WSL interop is enabled
func (c *Client) EnsureInterop() error {
	interopFile := "/proc/sys/fs/binfmt_misc/WSLInterop"
	
	if _, err := os.Stat(interopFile); err == nil {
		c.logger.Debug("WSL interop is enabled")
		return nil
	}
	
	c.logger.Warn("WSL interop not enabled, attempting to enable...")
	
	// Try to enable interop
	cmd := exec.Command("sudo", "sh", "-c",
		`echo ":WSLInterop:M::MZ::/init:PF" > /proc/sys/fs/binfmt_misc/register`)
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("failed to enable WSL interop: %w", err)
	}
	
	c.logger.Success("WSL interop enabled")
	return nil
}

// AttachVHD attaches a VHD to WSL
func (c *Client) AttachVHD(path string) (*AttachResult, error) {
	if err := c.EnsureInterop(); err != nil {
		return nil, err
	}
	
	c.logger.Debug("wsl.exe --mount --vhd %q --bare", path)
	
	cmd := exec.Command("wsl.exe", "--mount", "--vhd", path, "--bare")
	output, err := cmd.CombinedOutput()
	
	// Clean null bytes from output
	output = bytes.ReplaceAll(output, []byte{0}, []byte{})
	
	if err != nil {
		outStr := string(output)
		if strings.Contains(outStr, "WSL_E_USER_VHD_ALREADY_ATTACHED") ||
			strings.Contains(outStr, "already attached") {
			return nil, types.ErrVHDAlreadyAttached
		}
		return nil, fmt.Errorf("wsl.exe attach failed: %s", outStr)
	}
	
	return &AttachResult{WasNew: true}, nil
}

// DetachVHD detaches a VHD from WSL
func (c *Client) DetachVHD(path string) error {
	if err := c.EnsureInterop(); err != nil {
		return err
	}
	
	c.logger.Debug("wsl.exe --unmount %q", path)
	
	ctx, cancel := context.WithTimeout(context.Background(), c.detachTimeout)
	defer cancel()
	
	cmd := exec.CommandContext(ctx, "wsl.exe", "--unmount", path)
	output, err := cmd.CombinedOutput()
	
	// Clean null bytes
	output = bytes.ReplaceAll(output, []byte{0}, []byte{})
	
	if ctx.Err() == context.DeadlineExceeded {
		return fmt.Errorf("detach timed out after %v", c.detachTimeout)
	}
	
	if err != nil {
		outStr := string(output)
		if strings.Contains(outStr, "ERROR_FILE_NOT_FOUND") {
			return types.ErrVHDNotAttached
		}
		return fmt.Errorf("wsl.exe unmount failed: %s", outStr)
	}
	
	return nil
}

// GetBlockDevices returns list of block device names
func (c *Client) GetBlockDevices() ([]string, error) {
	c.logger.Debug("lsblk -J")
	
	cmd := exec.Command("sudo", "lsblk", "-J")
	output, err := cmd.Output()
	if err != nil {
		return nil, fmt.Errorf("lsblk failed: %w", err)
	}
	
	var result struct {
		BlockDevices []struct {
			Name string `json:"name"`
		} `json:"blockdevices"`
	}
	
	if err := json.Unmarshal(output, &result); err != nil {
		return nil, fmt.Errorf("failed to parse lsblk output: %w", err)
	}
	
	var devices []string
	for _, dev := range result.BlockDevices {
		devices = append(devices, dev.Name)
	}
	
	return devices, nil
}

// DetectNewDevice detects a newly attached device by comparing snapshots
func (c *Client) DetectNewDevice(oldDevices []string) (string, error) {
	// Build map of old dynamic VHD devices (sd[d-z] pattern)
	oldDevMap := make(map[string]bool)
	dynamicPattern := regexp.MustCompile(`^sd[d-z][a-z]*$`)
	
	for _, dev := range oldDevices {
		if dynamicPattern.MatchString(dev) {
			oldDevMap[dev] = true
		}
	}
	
	// Sleep to let kernel recognize device
	time.Sleep(c.sleepAfterAttach)
	
	// Get new device list
	newDevices, err := c.GetBlockDevices()
	if err != nil {
		return "", err
	}
	
	// Find new device
	for _, dev := range newDevices {
		if !oldDevMap[dev] && dynamicPattern.MatchString(dev) {
			c.logger.Debug("New device detected: %s", dev)
			return dev, nil
		}
	}
	
	return "", errors.New("no new device detected")
}

// GetUUIDByDevice gets the UUID of a device
func (c *Client) GetUUIDByDevice(devName string) (string, error) {
	c.logger.Debug("sudo blkid -s UUID -o value /dev/%s", devName)
	
	cmd := exec.Command("sudo", "blkid", "-s", "UUID", "-o", "value", "/dev/"+devName)
	output, err := cmd.Output()
	if err != nil {
		return "", nil // Device may not be formatted
	}
	
	uuid := strings.TrimSpace(string(output))
	if uuid == "" {
		return "", nil
	}
	
	return uuid, nil
}

// IsAttached checks if a VHD is attached by UUID
func (c *Client) IsAttached(uuid string) (bool, error) {
	c.logger.Debug("Checking if UUID %s is attached", uuid)
	
	cmd := exec.Command("lsblk", "-f", "-J")
	output, err := cmd.Output()
	if err != nil {
		return false, err
	}
	
	var result struct {
		BlockDevices []struct {
			UUID string `json:"uuid"`
		} `json:"blockdevices"`
	}
	
	if err := json.Unmarshal(output, &result); err != nil {
		return false, err
	}
	
	for _, dev := range result.BlockDevices {
		if dev.UUID == uuid {
			return true, nil
		}
	}
	
	return false, nil
}

// IsMounted checks if a VHD is mounted by UUID
func (c *Client) IsMounted(uuid string) (bool, error) {
	mp, err := c.GetMountPoint(uuid)
	if err != nil {
		return false, err
	}
	return mp != "", nil
}

// GetMountPoint gets the mount point for a UUID
func (c *Client) GetMountPoint(uuid string) (string, error) {
	cmd := exec.Command("lsblk", "-f", "-J")
	output, err := cmd.Output()
	if err != nil {
		return "", err
	}
	
	var result struct {
		BlockDevices []struct {
			UUID        string   `json:"uuid"`
			MountPoints []string `json:"mountpoints"`
		} `json:"blockdevices"`
	}
	
	if err := json.Unmarshal(output, &result); err != nil {
		return "", err
	}
	
	for _, dev := range result.BlockDevices {
		if dev.UUID == uuid && len(dev.MountPoints) > 0 {
			for _, mp := range dev.MountPoints {
				if mp != "" {
					return mp, nil
				}
			}
		}
	}
	
	return "", nil
}

// FindUUIDByPath finds UUID for a VHD path with multi-VHD safety
func (c *Client) FindUUIDByPath(path string) (string, error) {
	// This would integrate with tracking file lookup
	// For now, implement the safety check
	
	count, err := c.CountDynamicVHDs()
	if err != nil {
		return "", err
	}
	
	if count > 1 {
		return "", types.ErrMultipleVHDs
	}
	
	if count == 0 {
		return "", types.ErrVHDNotAttached
	}
	
	// Safe: exactly one VHD
	return c.findDynamicVHDUUID()
}

// CountDynamicVHDs counts non-system attached VHDs
func (c *Client) CountDynamicVHDs() (int, error) {
	devices, err := c.GetBlockDevices()
	if err != nil {
		return 0, err
	}
	
	pattern := regexp.MustCompile(`^sd[d-z][a-z]*$`)
	count := 0
	
	for _, dev := range devices {
		if pattern.MatchString(dev) {
			count++
		}
	}
	
	return count, nil
}

// findDynamicVHDUUID finds UUID of the single dynamic VHD
func (c *Client) findDynamicVHDUUID() (string, error) {
	devices, err := c.GetBlockDevices()
	if err != nil {
		return "", err
	}
	
	pattern := regexp.MustCompile(`^sd[d-z][a-z]*$`)
	
	for _, dev := range devices {
		if pattern.MatchString(dev) {
			uuid, err := c.GetUUIDByDevice(dev)
			if err == nil && uuid != "" {
				return uuid, nil
			}
		}
	}
	
	return "", types.ErrVHDNotFound
}

