// Example: internal/validation/validation.go
// Input validation functions

package validation

import (
	"errors"
	"regexp"
	"strings"
)

// Validation errors
var (
	ErrEmptyInput          = errors.New("input is empty")
	ErrInvalidWindowsPath  = errors.New("invalid Windows path format")
	ErrInvalidUUID         = errors.New("invalid UUID format")
	ErrInvalidMountPoint   = errors.New("invalid mount point format")
	ErrInvalidDeviceName   = errors.New("invalid device name format")
	ErrInvalidSize         = errors.New("invalid size format")
	ErrInvalidFilesystem   = errors.New("invalid filesystem type")
	ErrDangerousPath       = errors.New("path contains dangerous characters")
	ErrPathTraversal       = errors.New("path contains traversal patterns")
	ErrPathTooLong         = errors.New("path exceeds maximum length")
)

// Regular expressions for validation
var (
	windowsPathPattern = regexp.MustCompile(`^[A-Za-z]:[/\\]`)
	uuidPattern        = regexp.MustCompile(`^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$`)
	deviceNamePattern  = regexp.MustCompile(`^sd[a-z]+$`)
	sizePattern        = regexp.MustCompile(`^[0-9]+(\.[0-9]+)?[KMGT]?[B]?$`)
	dangerousChars     = regexp.MustCompile("[`$();|&<>\"'*?\\[\\]!~]")
)

// Allowed filesystem types (whitelist)
var allowedFilesystems = map[string]bool{
	"ext2":  true,
	"ext3":  true,
	"ext4":  true,
	"xfs":   true,
	"btrfs": true,
	"ntfs":  true,
	"vfat":  true,
	"exfat": true,
}

// MaxPathLength is the maximum allowed path length
const MaxPathLength = 4096

// ValidateWindowsPath validates a Windows path format
// Security: Prevents command injection and path traversal
func ValidateWindowsPath(path string) error {
	if path == "" {
		return ErrEmptyInput
	}

	// Check length
	if len(path) > MaxPathLength {
		return ErrPathTooLong
	}

	// Must start with drive letter
	if !windowsPathPattern.MatchString(path) {
		return ErrInvalidWindowsPath
	}

	// Check for dangerous characters
	if dangerousChars.MatchString(path) {
		return ErrDangerousPath
	}

	// Check for path traversal
	if strings.Contains(path, "..") {
		return ErrPathTraversal
	}

	// Check for control characters
	for _, r := range path {
		if r < 32 || r == 127 {
			return ErrDangerousPath
		}
	}

	return nil
}

// ValidateUUID validates a UUID format (RFC 4122)
func ValidateUUID(uuid string) error {
	if uuid == "" {
		return ErrEmptyInput
	}

	// UUID must be exactly 36 characters
	if len(uuid) != 36 {
		return ErrInvalidUUID
	}

	if !uuidPattern.MatchString(uuid) {
		return ErrInvalidUUID
	}

	return nil
}

// ValidateMountPoint validates a Linux mount point path
func ValidateMountPoint(path string) error {
	if path == "" {
		return ErrEmptyInput
	}

	// Check length
	if len(path) > MaxPathLength {
		return ErrPathTooLong
	}

	// Must be absolute path
	if !strings.HasPrefix(path, "/") {
		return ErrInvalidMountPoint
	}

	// Check for dangerous characters
	if dangerousChars.MatchString(path) {
		return ErrDangerousPath
	}

	// Check for path traversal
	if strings.Contains(path, "..") {
		return ErrPathTraversal
	}

	// Check for leading/trailing spaces
	if path != strings.TrimSpace(path) {
		return ErrDangerousPath
	}

	return nil
}

// ValidateDeviceName validates a device name (e.g., sdd, sde)
func ValidateDeviceName(name string) error {
	if name == "" {
		return ErrEmptyInput
	}

	// Check length
	if len(name) > 10 {
		return ErrInvalidDeviceName
	}

	if !deviceNamePattern.MatchString(name) {
		return ErrInvalidDeviceName
	}

	return nil
}

// ValidateSizeString validates a size string (e.g., "5G", "500M")
func ValidateSizeString(size string) error {
	if size == "" {
		return ErrEmptyInput
	}

	// Check length
	if len(size) > 20 {
		return ErrInvalidSize
	}

	// Convert to uppercase for matching
	sizeUpper := strings.ToUpper(size)
	if !sizePattern.MatchString(sizeUpper) {
		return ErrInvalidSize
	}

	return nil
}

// ValidateFilesystemType validates filesystem type using whitelist
func ValidateFilesystemType(fsType string) error {
	if fsType == "" {
		return ErrEmptyInput
	}

	fsLower := strings.ToLower(fsType)
	if !allowedFilesystems[fsLower] {
		return ErrInvalidFilesystem
	}

	return nil
}

// SanitizeString removes control characters from string
func SanitizeString(input string) string {
	var result strings.Builder
	for _, r := range input {
		if r >= 32 && r != 127 {
			result.WriteRune(r)
		}
	}
	return result.String()
}

