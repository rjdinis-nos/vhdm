// Example: internal/cli/attach.go
// Attach command implementation

package cli

import (
	"fmt"

	"github.com/spf13/cobra"
	"github.com/user/vhdm/internal/types"
	"github.com/user/vhdm/internal/validation"
)

func newAttachCmd() *cobra.Command {
	var vhdPath string

	cmd := &cobra.Command{
		Use:   "attach",
		Short: "Attach a VHD to WSL (without mounting)",
		Long: `Attach a VHD file to WSL as a block device.

The VHD will be accessible as /dev/sdX after attachment.
Use 'mount' command to attach AND mount in one step.`,
		Example: `  vhdm attach --vhd-path C:/VMs/disk.vhdx`,
		RunE: func(cmd *cobra.Command, args []string) error {
			return runAttach(vhdPath)
		},
	}

	cmd.Flags().StringVar(&vhdPath, "vhd-path", "", "VHD file path (Windows format)")
	cmd.MarkFlagRequired("vhd-path")

	return cmd
}

func runAttach(vhdPath string) error {
	ctx := appCtx
	log := ctx.Logger

	// Validate path
	if err := validation.ValidateWindowsPath(vhdPath); err != nil {
		return &types.VHDError{
			Op:   "attach",
			Path: vhdPath,
			Err:  err,
			Help: "Path must be a valid Windows path (e.g., C:/path/to/file.vhdx)",
		}
	}

	log.Debug("Attach operation starting for: %s", vhdPath)

	// Check if VHD file exists
	wslPath := ctx.WSL.ConvertPath(vhdPath)
	if !ctx.WSL.FileExists(wslPath) {
		return &types.VHDError{
			Op:   "attach",
			Path: vhdPath,
			Err:  types.ErrVHDNotFound,
			Help: fmt.Sprintf("VHD file not found at: %s", wslPath),
		}
	}

	// Take snapshot of current devices
	oldDevices, err := ctx.WSL.GetBlockDevices()
	if err != nil {
		return fmt.Errorf("failed to get block devices: %w", err)
	}

	// Attempt to attach
	result, err := ctx.WSL.AttachVHD(vhdPath)
	if err != nil {
		// Check if already attached
		if types.IsAlreadyAttached(err) {
			// Find existing UUID
			uuid, findErr := ctx.WSL.FindUUIDByPath(vhdPath)
			if findErr != nil {
				return findErr
			}
			
			if quiet {
				fmt.Printf("%s (%s): already attached\n", vhdPath, uuid)
			} else {
				log.Info("VHD is already attached")
				printAttachResult(vhdPath, uuid, "", false)
			}
			return nil
		}
		return &types.VHDError{
			Op:   "attach",
			Path: vhdPath,
			Err:  err,
		}
	}

	// Detect new device
	devName, err := ctx.WSL.DetectNewDevice(oldDevices)
	if err != nil {
		return fmt.Errorf("failed to detect attached device: %w", err)
	}

	// Get UUID if formatted
	uuid, _ := ctx.WSL.GetUUIDByDevice(devName)

	// Save to tracking file
	if err := ctx.Tracker.SaveMapping(vhdPath, uuid, "", devName); err != nil {
		log.Warn("Failed to save tracking info: %v", err)
	}

	// Remove from detach history
	ctx.Tracker.RemoveDetachHistory(vhdPath)

	// Output
	if quiet {
		if uuid != "" {
			fmt.Printf("%s (%s): attached\n", vhdPath, uuid)
		} else {
			fmt.Printf("%s (/dev/%s): attached,unformatted\n", vhdPath, devName)
		}
		return nil
	}

	printAttachResult(vhdPath, uuid, devName, true)
	return nil
}

func printAttachResult(path, uuid, devName string, newlyAttached bool) {
	// Table output for verbose mode
	fmt.Println()
	fmt.Println("VHD Attach Result")
	fmt.Println()
	fmt.Printf("| %-14s | %-50s |\n", "Property", "Value")
	fmt.Println("+----------------+----------------------------------------------------+")
	fmt.Printf("| %-14s | %-50s |\n", "Path", path)
	if uuid != "" {
		fmt.Printf("| %-14s | %-50s |\n", "UUID", uuid)
	} else {
		fmt.Printf("| %-14s | %-50s |\n", "UUID", "(unformatted)")
	}
	if devName != "" {
		fmt.Printf("| %-14s | %-50s |\n", "Device", "/dev/"+devName)
	}
	status := "attached"
	if newlyAttached {
		status = "attached (newly)"
	}
	fmt.Printf("| %-14s | %-50s |\n", "Status", status)
	fmt.Println("+----------------+----------------------------------------------------+")
}

